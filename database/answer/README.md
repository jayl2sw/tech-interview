# Database

> **데이터베이스**는 여러 사용자나 응용 프로그램들이 공유하고 사용할 수 있는 데이터의 집합을 의미합니다. 이러한 데이터는 구조화되어 있어 검색, 수정, 추가, 삭제 등의 작업을 편리하게 할 수 있도록 되어 있습니다.



</br>

#### 1. RDB & NoSQL

* **RDB와 NoSQL의 차이점에 대해서 설명해주세요.**

  > RDB와 NoSQL의 가장 큰 차이점은 Schema의 여부와 관계의 존재 여부입니다. RDB의 경우 정해진 스키마에 부합하는 데이터만을 저장할 수 있지만 NoSQL의 경우 스키마가 존재하지 않고 Documents나 Key-Value 등의 방식으로 저장합니다. 또한 RDB에서는 여러가지 Table에 대한 관계를 통해 데이터 간의 상관관계를 설정하지만 NoSQL의 경우에는 하나의 documents에 모든 데이터가 들어가 있기 때문에 관계를 사용하지 않습니다. 이런 특성 때문에 NoSQL은 입출력 속도가 빠르며 Scale Out에 적합합니다.

* **본인이 사용한 RDBMS 기준으로 쿼리 실행 과정을 설명해주세요.**

  > 클라이언트가 DBMS에 SQL문을 요청합니다. DB는 해당 요청을 받아 Parser를 이용해 해당 SQL문을 파싱합니다. 이 과정에서 SQL 문법의 유효성 검사를 진행하고 트리 형식으로 변환됩니다. 이후 전처리기를 이용하여 Parse Tree를 기반으로 SQL 문장 구조를 체크하고 토큰이 유효한지 체크합니다. 이후 옵티마이저가 Tree를 기반으로 최적 SQL 실행 계획을 수립합니다. 이후 실행 엔진이 실행 계획을 기반으로 스토리지 엔진을 호출해서 실제 데이터 변경을 수행합니다.
  >
  > [참고](https://www.youtube.com/watch?v=vQFGBZemJLQ)

* **스토리지 엔진이 무엇이며 실행 엔진과는 무슨 차이점이 있는지 말해주세요.**

  > 스토리지 엔진은 쿼리 실행 엔진이 요청하는 대로 데이터를 실제로 디스크에 저장하고 읽는 역할을 수행합니다. Handler API에 의해 동작하며 플러그인 형태로 제공되기 때문에 사용자는 원하는 스토리지 엔진을 사용할 수 있습니다. 실행엔진의 경우 주어진 실행 계획을 바탕으로 스토리지 엔진을 호출하는 역할을 수행합니다.

* **옵티마이저는 무엇인지 설명해주세요.**

  > 옵티마이저란 Parser Tree를 기반으로 최적 SQL 실행계획을 수립하는 모듈입니다. 옵티마이저는 다양한 실행 계획을 고려하고, 각 계획의 비용을 추정하여 가장 효율적인 실행 계획을 선택합니다. (다양한 실행 계획들을 비교하는데 있어 DBMS의 성능 통계정보를 사용합니다.) 이를 통해 데이터베이스 시스템의 성능과 효율성을 향상시키는 역할을 합니다.

* **NoSQL의 종류를 아는대로 말해주세요.**

  > MongoDB와 같이 documents를 기준으로 데이터를 저장하는 documents-based, redis와 같이 key-value 형태로 데이터를 저장하는 Key-Value DB, cassandra와 같이 각 행마다 다른 Column들을 가지는 column family-based 방식 등이 있습니다.

* **회사 서비스과 관련하여 각 DB들을 어떻게 사용할 수 있을 지 말해주세요.**



</br>

#### 2. Transaction

* **트랜잭션이 무엇이고 어떤 특징을 가지는지 말해주세요(ACID).**

  > 트랜잭션이란, 데이터베이스에 적용되는 변경사항들의 최소 단위로써 ACID 원칙을 따릅니다. A, 원자성이란, 하나의 트랜잭션 안의 변경 사항들은 모두 commit이 되거나 또는 모두 rollback이 되어야 함을 의미합니다. C, 일관성은 트랜잭션이 일어난 후에도 DB 스키마를 만족하여야함을 의미합니다. I, 고립성이란 동시에 수행되는 트랜잭션 간에 영향을 미치지 않아야 함을 의미합니다. 마지막으로 D, 영구성은 커밋된 트랜잭션이 영구적으로 보존되어 시스템 오류 등의 문제가 발생하더라도 복구될 수 있어야 함을 의미합니다.

* **ACID 중 데이터베이스에서 원자성을 보장하는 방식을 설명해주세요.**

  > 

* **데이터베이스가 Durability를 보장하는 방식을 설명해주세요**

  > Durability는 성공적으로 커밋된 트랜잭션은 전원 차단, 시스템 오류 등의 문제가 발생하더라도 복구될 수 있어야 함을 의미합니다. DBMS는 일반적으로 logging을 통해 durability를 구현합니다. 트랜잭션이 커밋되면 이는 트랜잭션 로그에 저장되며, 해당 로그는 비휘발성인 디스크에 저장되게 됩니다. 시스템 오류가 발생한 경우 DBMS의 복구 메커니즘은 해당 트랜잭션 로그를 사용하여 마지막 트랜잭션이 커밋된 시점의 DB를 재구성합니다.

* **트랜잭션을 사용해본 경험이 있는지? 어떤 경우에 사용할 수 있나요?**

  > 

* **readOnly 로직의 경우 트랜잭션을 걸지 않아도 될까요?**

* **분산 환경에서는 트랜잭션을 어떻게 관리할 수 있을까요?**



</br>

#### 3. 트랜잭션 격리 수준

* **트랜잭션 격리 수준에 대해 설명해주세요.**
* **트랜잭션 격리 수준에 따라 발생할 수 있는 문제점들을 말해주세요.**
* **MySQL을 사용하고 있다면 MySQL 스토리지 엔진(InnoDB)를 기준으로 Undo 영역과 Redo 영역에 대해 설명해주세요**



</br>

#### 4. 조인 (JOIN)

* **알고 있는 JOIN의 종류들을 말해주세요.**

  > 결과적인 측면에서는 INNER JOIN, OUTER JOIN, LEFT JOIN, RIGHT JOIN, NATURAL JOIN 등이 있으며, JOIN의 동작 방식 적인 측면에서는 NL 조인, Sort Merge 조인, 해시 조인 등이 있습니다.

* **JOIN은 내부적으로 다양한 구현 방식을 사용하고 있습니다. JOIN의 원리에 대해 아는대로 말해주세요.**

  > JOIN의 구현 방식은 NL 조인, Sort Merge 조인, 해시 조인 등이 있습니다.
  >
  > 먼저 NL 조인(Nested Loop JOIN)의 경우 하나의 driving table을 순회하면서 다른 테이블(driven table)에서 JOIN 조건을 만족하는 레코드들을 찾아 JOIN을 수행하는 방식입니다. 이 방식의 경우에는 driven table에 인덱스 설정 여부가 성능에 큰 영향을 미치기 때문에 주로 driven table에 인덱스가 설정되어 있을 때 사용합니다.
  >
  > Sort Merge JOIN과 같은 경우에는 두 Table을 조건 칼럼에 대해 정렬작업을 수행한 후 조인하는 방식을 진행합니다. 이는 보통 Driven Table에 적절한 인덱스가 존재하지 않아 NL JOIN이 비효율 적이거나, Equal Join이 아닌 
  >
  > [참고](https://velog.io/@jayl2sw/Database-%EC%A1%B0%EC%9D%B8Join%EC%9D%98-%EC%88%98%ED%96%89-%EC%9B%90%EB%A6%AC)

* **JOIN의 성능과 Index 사이에 어떤 관계가 있는지 말해주세요.**

  > NL JOIN의 경우 driven table에 index가 없다면 해당 테이블을 풀스캔 해야하기 때문에 Index가 있는 것이 driven table을 조회하는데 성능이 훨씬 좋습니다.

* **어떤 JOIN 방식을 사용하는지 어떻게 알 수 있나요?**

  > Database에서 EXPLAIN을 이용해 실행계획을 확인하면 해당 실행계획의 JOIN 방식을 알 수 있습니다. MySQL의 경우 NL만 지원합니다.



</br>

#### 5. 인덱스 (Index)

* **인덱스가 무엇인지 설명해주세요.**

  > 인덱스란 DB에서 데이터의 검색 및 조회를 빠르게 하기 위해 사용되는 자료구조입니다. 인덱스는 테이블의 하나 이상의 컬럼에 대한 값과, 해당 값이 저장된 행의 위치를 매핑하는 역할을 합니다. Index는 DB 성능을 향상시키고 검색 속도를 높이는데 중요한 역할을 합니다.

* **인덱스는 어떤 구조로 구현될 수 있나요?**

  > 인덱스는 B tree 구조나 해시 테이블을 이용해서 구현될 수 있습니다. B 트리는 균형 이진 트리의 변형으로서, 트리의 높이를 최소화하여 검색 속도를 향상시키는 특징을 가지고 있습니다. 각 노드는 값들과 하위 노드를 가리키는 포인터를 가지고 있으며 값에 대한 대소비교를 통해 적합한 하위 노드를 탐색합니다.

* **B-tree와 B+ tree의 차이점과 각각의 장단점에 대해 설명해주세요.**

  > B tree의 경우 각 노드는 값과 포인터를 가지고 있습니다. B+ tree의 경우 각 노드는 하위 노드의 포인터만을 가지고 있으며 모든 값들은 리프노드에 있습니다. 또한, 모든 리프 노드들은 Linked List 형태로 연결되어 있어 구간 탐색에 용이하며, 모든 데이터 조회 시에도 한번의 선형 탐색으로 조회할 수 있습니다.
  >
  > [참고](https://velog.io/@jayl2sw/index)

* **Hash Table을 이용한 Index의 한계점은 무엇인가요?**

  > hash table을 이용한 index의 경우 부등호 연산(<>)이 포함되어 있을 경우 모든 데이터를 순회해야 하기 때문에 비효율적입니다.

* **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**

* **인덱스를 생성하는 기준을 대략적으로 설명해주세요.**

* **where 절에서 like "A%"와 "%A%"의 동작방식에서의 차이를 말해주세요.**

  > A%의 경우 해당 컬럼에 Index가 존재한다면 해당 인덱스를 사용하여 조회할 수 있지만, "%A%의 경우 Index를 탈 수 없습니다. 따라서 일반적으로 관리자 모드 등에서는 "%A%"는 사용하지 않습니다.



</br>

#### 6. 정규화

* **정규화는 무엇이고 왜 하는 것인지 말해주세요.**

  > **정규화**란 관계형 데이터베이스의 설계에서 <u>중복을 최소화하게 데이터를 구조화하는 프로세스</u>를 의미합니다.

* **3차 정규화에 대해서 설명해주세요.**

  > 3차 정규화는 1차, 2차 정규화를 만족하며 즉, 모든 도메인이 원자값이고, 모든 종속자들이 결정자에 완전 함수적 종속하며, 이행적 함수적 종속이 없는 상태를 의미합니다. 이는 A -> B B -> C와 같이 어떠한 종속자도 결정자가 되지 않음을 뜻합니다.

* **정규화를 진행할 수록 DB의 성능이 향상되나요? 그 이유에 대해서도 설명해주세요.**

  > 정규화란 중복을 최소화 함으로써 이상 현상을 줄이기 위한 프로세스입니다. 따라서 일반적으로 정규화를 진행 했을 때, 조인에 따른 오버헤드가 발생하기 때문에 성능은 하락할 수 있습니다. 따라서 정규화 정도에 따른 장단점을 명확히 이해하고 각각의 테이블에 적합한 정규화 레벨을 설정하는 것이 중요합니다.

  

</br>

#### 7. 락 (Lock)

* **DB Lock이 무엇인지 설명해주세요.**

* **Optimistic Lock과 Pessimistic Lock에 대해서 설명해주세요.**

* **공유 락과 배타 락에 대해 설명해주세요.**

* **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**

  > 두개의 트랜잭션이 같은 두개의 리소스에 배타락을 걸어야 한다고 가정하고 각각 하나의 리소스에 Lock을 건 상태일 때, 두 트랜잭션 모두 Lock이 해제되기를 기다려야 합니다. 이런 상황을 다중 트랜잭션에서의 Deadlock 상황이라고 합니다. 이를 해결하기 위해서는 트랜잭션의 진행 방향을 같은 방향으로 처리하는 방법이 있습니다. 또한 트랜잭션 처리 속도를 줄이고 Lock Timeout을 이용하여 잠금 해제 시간을 조절하는 방식도 존재합니다.



</br>

#### 8. Connection Pool

* **Connection Pool이 무엇인지 설명해주세요.**

  > 일반적으로 클라이언트에서 DB에 어떤 요청을 진행하면 커넥션을 맺고 해당 요청을 수행한 뒤 커넥션을 해제하는 과정을 거칩니다. 이 때, DB 서버와의 연결 비용을 최소화 하기 위해 어플리케이션과 DB사이에 일정 수의 커넥션을 생성해두고 어플리케이션에서는 DB 접근이 필요할 때마다 이미 생성되어 있는 connection을 가져다가 쓰고 반환하는 방식을 Connection Pool이라고 합니다.

* **DB와 Client가 Connection을 구성하는 방법을 설명해주세요.**

  > 



</br>

#### 9. Traffic Management

* **만약 테이블 내에 데이터가 너무 많아서 성능이 저하되는 경우 어떻게 처리할 수 있을 지 말해주세요.**

  > Table 내의 데이터가 너무 많아서 성능이 저하되는 경우에는 Partitioning이나 

* **만약 데이터베이스에 요청이 너무 많아서 성능이 저하되는 경우 어떻게 처리할 수 있을 지 말해주세요.**

* **수평 파티셔닝과 샤딩(Sharding)의 차이점이 무엇인가요?**
* **만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**



</br>



  

